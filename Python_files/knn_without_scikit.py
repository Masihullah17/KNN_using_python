# -*- coding: utf-8 -*-
"""KNN_without_scikit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hq5VOEVJy0VzJO10NqWaxzmFmdo36JLT
"""

import csv
import random
import math
import operator

def loadingData(filename,split_ratio,trainingSet=[],testSet=[]):
  with open(filename,'r') as file:
    data = csv.reader(file)
    dataset = list(data)
    for x in range(len(dataset)-1):
      for y in range(4):
        dataset[x][y] = float(dataset[x][y])
      if random.random() < split_ratio:
        trainingSet.append(dataset[x])
      else:
        testSet.append(dataset[x])

trainingSet = []
testSet = []
loadingData('iris.data',0.66,trainingSet,testSet)

print('Train:' + repr(len(trainingSet)))
print('Test:' + repr(len(testSet)))

def euclideanDistance(x1,x2,length):
  distance =0
  for x in range(length):
    distance = (x1[x]-x2[x])**2
  return math.sqrt(distance)

#testing function
data1 = [2,2,2,'a']
data2 = [4,4,4,'b']
distance = euclideanDistance(data1,data2,3)
print('Distance:' + repr(distance))

def getNeighbors(trainingSet,testInstance,k):
  distances = []
  length = len(testInstance)-1
  for x in range(len(trainingSet)):
    dist = euclideanDistance(testInstance,trainingSet[x],length)
    distances.append((trainingSet[x],dist)) 
  distances.sort(key=operator.itemgetter(1))
  neighbours = []
  for x in range(k):
    neighbours.append(distances[x][0])
  return neighbours

#testing neighbours function
trainSet = [[2, 2, 2, 'a'], [4, 4, 4, 'b']]
testInstance = [5, 5, 5]
k = 1
neighbors = getNeighbors(trainSet, testInstance, 1)
print(neighbors)

#Function to get responses
def responses(neighbors):
  classVotes = {}
  for x in range(len(neighbors)):
    response = neighbors[x][-1]
    if response in classVotes:
      classVotes[response] += 1
    else:
      classVotes[response] = 1
  sortedVotes = sorted(classVotes.items(), key=operator.itemgetter(1),reverse=True)
  return sortedVotes[0][0]

#testing response function using sample data
neighbors = [[1,1,1,'a'], [2,2,2,'a'], [3,3,3,'b']]
response = responses(neighbors)
print(response)

#Function to get accuracy
def getAccuracy(testSet,predictions):
  correct = 0
  for x in range(len(testSet)):
    if testSet[x][-1] == predictions[x]:
      correct += 1
  return (correct / float(len(testSet)) ) * 100.0

#testing accuracy function using sample data
testSet = [[1,1,1,'a'], [2,2,2,'a'], [3,3,3,'b']]
predictions = ['a', 'a', 'a']
accuracy = getAccuracy(testSet, predictions)
print(accuracy)

def main():
  #preparing data
  trainingSet = []
  testSet = []
  split_ratio = 0.67
  loadingData('iris.data',split_ratio,trainingSet,testSet)
  #generating predictions
  predictions = []
  k = 3
  for x in range(len(testSet)):
    neighbors = getNeighbors(trainingSet,testSet[x],k)
    response = responses(neighbors)
    predictions.append(response)
    #print('Predicted: ' + repr(response) + 'Actual: ' + repr(testSet[x][-1]))
  accuracy = getAccuracy(testSet,predictions)
  print('Accuracy: ' + repr(accuracy) + '%')

main()

